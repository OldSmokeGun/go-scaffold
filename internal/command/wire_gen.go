// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package command

import (
	"context"
	"database/sql"
	"go-scaffold/internal/app/adapter/cron"
	"go-scaffold/internal/app/adapter/cron/job"
	"go-scaffold/internal/app/adapter/cron/scheduler"
	"go-scaffold/internal/app/adapter/kafka"
	"go-scaffold/internal/app/adapter/kafka/consumer"
	"go-scaffold/internal/app/adapter/kafka/handler"
	"go-scaffold/internal/app/adapter/server"
	"go-scaffold/internal/app/adapter/server/grpc"
	v1_2 "go-scaffold/internal/app/adapter/server/grpc/handler/v1"
	router2 "go-scaffold/internal/app/adapter/server/grpc/router"
	"go-scaffold/internal/app/adapter/server/http"
	"go-scaffold/internal/app/adapter/server/http/handler/v1"
	"go-scaffold/internal/app/adapter/server/http/router"
	"go-scaffold/internal/app/controller"
	"go-scaffold/internal/app/pkg/client"
	"go-scaffold/internal/app/pkg/db"
	"go-scaffold/internal/app/pkg/gorm"
	"go-scaffold/internal/app/repository"
	"go-scaffold/internal/app/usecase"
	"go-scaffold/internal/config"
	"go-scaffold/pkg/trace"
	"golang.org/x/exp/slog"
)

// Injectors from wire.go:

func initServer(contextContext context.Context, appName config.AppName, env config.Env, logger *slog.Logger, traceTrace *trace.Trace) (*server.Server, func(), error) {
	configHTTP, err := config.GetHTTP()
	if err != nil {
		return nil, nil, err
	}
	greetController := controller.NewGreetController()
	greetHandler := v1.NewGreetHandler(greetController)
	services, err := config.GetServices()
	if err != nil {
		return nil, nil, err
	}
	clientGRPC := client.ProvideGRPC()
	traceHandler := v1.NewTraceHandler(logger, services, configHTTP, traceTrace, clientGRPC)
	kafka, err := config.GetKafka()
	if err != nil {
		return nil, nil, err
	}
	producerController := controller.NewProducerController(kafka)
	producerHandler := v1.NewProducerHandler(producerController)
	db, err := config.GetDB()
	if err != nil {
		return nil, nil, err
	}
	gormDB, cleanup, err := gorm.Provide(contextContext, db, logger)
	if err != nil {
		return nil, nil, err
	}
	userRepository := repository.NewUserRepository(gormDB)
	userUseCase := usecase.NewUserUseCase(userRepository)
	userController := controller.NewUserController(userUseCase)
	userHandler := v1.NewUserHandler(userController)
	apiV1Group := router.NewAPIV1Group(greetHandler, traceHandler, producerHandler, userHandler)
	apiGroup := router.NewAPIGroup(env, logger, configHTTP, apiV1Group)
	handler := router.New(logger, appName, env, configHTTP, apiGroup)
	httpServer := http.New(configHTTP, handler)
	configGRPC, err := config.GetGRPC()
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	v1GreetHandler := v1_2.NewGreetHandler(logger, greetController)
	v1UserHandler := v1_2.NewUserHandler(logger, userController)
	routerRouter := router2.New(v1GreetHandler, v1UserHandler)
	grpcServer := grpc.New(configGRPC, routerRouter)
	serverServer := server.New(contextContext, appName, httpServer, grpcServer)
	return serverServer, func() {
		cleanup()
	}, nil
}

func initCron(contextContext context.Context, appName config.AppName, env config.Env, logger *slog.Logger) (*cron.Cron, func(), error) {
	app, err := config.GetApp()
	if err != nil {
		return nil, nil, err
	}
	exampleJob := job.NewExampleJob(logger)
	schedulerScheduler := scheduler.New(app, exampleJob)
	cronCron, err := cron.New(logger, schedulerScheduler)
	if err != nil {
		return nil, nil, err
	}
	return cronCron, func() {
	}, nil
}

func initKafka(contextContext context.Context, appName config.AppName, env config.Env, logger *slog.Logger) (*kafka.Kafka, func(), error) {
	configKafka, err := config.GetKafka()
	if err != nil {
		return nil, nil, err
	}
	exampleHandler := handler.NewExampleHandler(logger)
	exampleConsumer, err := consumer.NewExampleConsumer(logger, configKafka, exampleHandler)
	if err != nil {
		return nil, nil, err
	}
	kafkaKafka := kafka.New(logger, exampleConsumer)
	return kafkaKafka, func() {
	}, nil
}

func initDB(contextContext context.Context, dbConn config.DBConn, logger *slog.Logger) (*sql.DB, func(), error) {
	sqlDB, cleanup, err := db.Provide(contextContext, dbConn)
	if err != nil {
		return nil, nil, err
	}
	return sqlDB, func() {
		cleanup()
	}, nil
}
